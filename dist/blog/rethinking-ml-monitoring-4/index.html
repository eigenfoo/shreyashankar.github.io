<!DOCTYPE html>
<html lang="en" class="astro-BVZIHDZO">
  <head>
    <!-- Global Metadata --><meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<link rel="icon" type="image/png" href="/icon.png">
<meta name="generator" content="Astro v2.10.9">

<!-- Font preloads -->
<link rel="preload" href="fonts/GTWalsheimPro-Light.woff" as="font" type="font/woff" crossorigin>
<link rel="preload" href="fonts/GTWalsheimPro-Medium.woff" as="font" type="font/woff" crossorigin>

<!-- Canonical URL -->
<link rel="canonical" href="https://shreya-shankar.com/blog/rethinking-ml-monitoring-4/">

<!-- Primary Meta Tags -->
<title>The Modern ML Monitoring Mess: Research Challenges (4/4)</title>
<meta name="title" content="The Modern ML Monitoring Mess: Research Challenges (4/4)">
<meta name="description" content="">

<!-- Open Graph / Facebook -->
<meta property="og:type" content="website">
<meta property="og:url" content="https://shreya-shankar.com/blog/rethinking-ml-monitoring-4/">
<meta property="og:title" content="The Modern ML Monitoring Mess: Research Challenges (4/4)">
<meta property="og:description" content="">
<meta property="og:image" content="https://shreya-shankar.com/icon.png">

<!-- Twitter -->
<meta property="twitter:card" content="summary_large_image">
<meta property="twitter:url" content="https://shreya-shankar.com/blog/rethinking-ml-monitoring-4/">
<meta property="twitter:title" content="The Modern ML Monitoring Mess: Research Challenges (4/4)">
<meta property="twitter:description" content="">
<meta property="twitter:image" content="https://shreya-shankar.com/icon.png">
    
  <link rel="stylesheet" href="/_astro/_...slug_.8be9d9b3.css" />
<link rel="stylesheet" href="/_astro/_...slug_.ee60a110.css" /></head>

  <body class="astro-BVZIHDZO">
    <header class="astro-3EF6KSR2">
  <nav class="astro-3EF6KSR2">
    <h2 class="astro-3EF6KSR2"><a href="/" class="astro-3EF6KSR2">Shreya Shankar</a></h2>
    <div class="internal-links astro-3EF6KSR2">
      <a href="/" class="astro-3EF6KSR2 astro-EIMMU3LG">
	Home
</a>
      <a href="/blog" class="astro-3EF6KSR2 astro-EIMMU3LG">
	Blog
</a>
      <a href="/papers" class="astro-3EF6KSR2 astro-EIMMU3LG">
	Papers
</a>
    </div>
    <div class="social-links astro-3EF6KSR2">
      <a href="https://twitter.com/sh_reya" target="_blank" class="astro-3EF6KSR2">
		<span class="sr-only astro-3EF6KSR2">Follow Shreya on Twitter</span>
        <svg viewBox="0 0 16 16" aria-hidden="true" width="32" height="32" class="astro-3EF6KSR2"><path fill="currentColor" d="M5.026 15c6.038 0 9.341-5.003 9.341-9.334 0-.14 0-.282-.006-.422A6.685 6.685 0 0 0 16 3.542a6.658 6.658 0 0 1-1.889.518 3.301 3.301 0 0 0 1.447-1.817 6.533 6.533 0 0 1-2.087.793A3.286 3.286 0 0 0 7.875 6.03a9.325 9.325 0 0 1-6.767-3.429 3.289 3.289 0 0 0 1.018 4.382A3.323 3.323 0 0 1 .64 6.575v.045a3.288 3.288 0 0 0 2.632 3.218 3.203 3.203 0 0 1-.865.115 3.23 3.23 0 0 1-.614-.057 3.283 3.283 0 0 0 3.067 2.277A6.588 6.588 0 0 1 .78 13.58a6.32 6.32 0 0 1-.78-.045A9.344 9.344 0 0 0 5.026 15z" class="astro-3EF6KSR2"></path></svg>
      </a>
      <a href="https://github.com/shreyashankar" target="_blank" class="astro-3EF6KSR2">
		<span class="sr-only astro-3EF6KSR2">Shreya's GitHub</span>
        <svg viewBox="0 0 16 16" aria-hidden="true" width="32" height="32" class="astro-3EF6KSR2"><path fill="currentColor" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.012 8.012 0 0 0 16 8c0-4.42-3.58-8-8-8z" class="astro-3EF6KSR2"></path></svg>
      </a>
    </div>
  </nav>
</header>
    <main class="astro-BVZIHDZO">
      <article class="astro-BVZIHDZO">
        <!-- <div class="hero-image">
					{heroImage && <img width={1020} height={510} src={heroImage} alt="" />}
				</div> -->
        <div class="prose astro-BVZIHDZO">
          <div class="title astro-BVZIHDZO">
            <div class="date astro-BVZIHDZO">
              <time datetime="2022-01-31T08:00:00.000Z">
	Jan 31, 2022
</time>
              
            </div>
            <h1 class="astro-BVZIHDZO">The Modern ML Monitoring Mess: Research Challenges (4/4)</h1>
            <hr class="astro-BVZIHDZO">
          </div>
          
	<p>In the last few pieces, I’ve discussed <a href="/blog/rethinking-ml-monitoring-1/">streaming ML evaluation</a>, thought about <a href="/blog/rethinking-ml-monitoring-2/">what to monitor</a> (across state and component axes), and explored <a href="/blog/rethinking-ml-monitoring-3/">failure modes in existing software monitoring tools</a> (e.g. Prometheus). In this final piece, <strong>I propose a broader research agenda for problems in ML monitoring,</strong><sup><a href="#user-content-fn-1" id="user-content-fnref-1" data-footnote-ref="" aria-describedby="footnote-label">1</a></sup> motivated by “real-world” post-deployment ML issues.</p>
<h2 id="preliminaries">Preliminaries</h2>
<p>We’ll walk through this agenda using an example:</p>
<ul>
<li><strong>Task:</strong> For a taxi ride, we want to predict the probability that a taxi rider will give a driver a tip greater than 10% of the fare. This is a binary classification problem. Predictions are float-valued between 0 and 1.</li>
<li><strong>Dataset:</strong> We use data between January 1, 2020 and May 31, 2020 collected from the <a href="https://www1.nyc.gov/site/tlc/about/tlc-trip-record-data.page">NYC Taxi Coalition</a>. This is an example of <a href="https://twitter.com/TweetAtAKK/status/1486026387525804034?s=20">“temporally evolving tabular data”</a> (phrase stolen from Arun Kumar).</li>
<li><strong>SLI:</strong> We measure accuracy, or the fraction of correctly-predicted examples when rounded to the nearest integer. In ML communities, the SLI is commonly referred to as the evaluation metric.</li>
<li><strong>Pipeline architecture:</strong> Our example only includes one model.<sup><a href="#user-content-fn-2" id="user-content-fnref-2" data-footnote-ref="" aria-describedby="footnote-label">2</a></sup> There are two pipelines – representing training and inference – that share some components, like cleaning and feature generation. Refer to the third piece in this series for a <a href="/blog/rethinking-ml-monitoring-3/#ml-task-data-source-and-pipeline">diagram</a>.</li>
</ul>
<h2 id="umbrella-of-challenges">Umbrella of Challenges</h2>
<p>My research agenda is focused primarily on data management, rather than algorithms.</p>
<h3 id="metric-computation">Metric Computation</h3>
<p>I separate metric computation into <em>coarse-grained</em> and <em>fine-grained</em> categories.<sup><a href="#user-content-fn-3" id="user-content-fnref-3" data-footnote-ref="" aria-describedby="footnote-label">3</a></sup> Coarse-grained metrics are SLIs (e.g., accuracy, precision, recall) that map most closely to business value and require some feedback, or labels. We use coarse-grained metrics to <em>detect</em> ML performance issues. Fine-grained metrics are metrics that might indicate or explain changes in coarse-grained metrics and don’t necessarily require labels (e.g. KL divergence between two consecutive sliding windows of a feature). We use fine-grained metrics to <em>diagnose</em> ML performance issues. Related, I think <strong>many organizations fall into this trap of monitoring fine-grained metrics first</strong>, as if some change on the median value of an obscure feature will give any actionable insight on whether to retrain a model, <strong>when coarse-grained metrics should be treated as first-class citizens</strong>.</p>
<h4 id="coarse-grained-monitoring-detecting-ml-performance-issues">Coarse-grained Monitoring: <em>Detecting</em> ML Performance Issues</h4>
<p>Surprisingly, organizations find it challenging to know the real-time value of their SLIs. Some reasons are:</p>
<p><strong>Separation between prediction and feedback components.</strong> If one pipeline makes predictions while another ingests feedback, we’d need to perform joins on a high-cardinality <a href="/blog/rethinking-ml-monitoring-3/">attribute</a>. This may not be a research problem per se, but an annoying engineering problem to think about, especially in the streaming setting.</p>
<p><strong>Changing subpopulations of interest.</strong> Many organizations monitor SLIs for different subpopulations (e.g. customers) Over time, new subpopulations or demographics might gradually enter the data stream. It’s hard for organizations to know <em>what</em> subpopulations to monitor – taking into account coverage (i.e. support), time-variation, or high training losses.</p>
<p><strong>Label lag.</strong> As a consequence of separation between prediction and feedback components, <em>after</em> we make a prediction, its corresponding feedback (i.e. label) arrives in the system after some time (or not at all). Delays may not be uniform across different predictions or subgroups. Lag is exacerbated in situations where humans are required to manually label data. Furthermore, we assume that <strong>label lag is a nonstationary time series</strong> (i.e. unanticipated issues may cause lag, and there might not be a pattern to it).</p>
<h5 id="scalable-monitoring-infrastructure">Scalable Monitoring Infrastructure</h5>
<p>Tackling the first two problems, especially at scale, calls for better monitoring infrastructure that prioritizes incrementally maintained joins, flexible definitions of SLIs (i.e. user-defined functions), intelligent suggestions for <em>what</em> to monitor, and the ability to add new SLI definitions post-deployment and compute them over historical windows of data. My <a href="/blog/rethinking-ml-monitoring-3/">last piece</a> demonstrated how Prometheus doesn’t meet any of these needs. To this end, I’m thinking about an ML monitoring system with the following layers:</p>
<p><strong>Storage.</strong> We’d need a time-series database for persistent storage (computed metric values, histograms or summaries, raw outputs, and feedback) and in-memory streams for fast joins and metric computation.</p>
<p><strong>Execution.</strong> Users should be able to specify metric functions as Python UDFs, which we could run incrementally on windows of data with a differential dataflow-based system <a href="https://cs.stanford.edu/~matei/courses/2015/6.S897/readings/naiad.pdf">(Murray et al.)</a>. Consider a hypothetical user workflow:</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">def</span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">compute_accuracy</span><span style="color: #E1E4E8">(curr_true, curr_pred):</span></span>
<span class="line"><span style="color: #E1E4E8">	</span><span style="color: #F97583">return</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">float</span><span style="color: #E1E4E8">(</span><span style="color: #79B8FF">sum</span><span style="color: #E1E4E8">(curr_true </span><span style="color: #F97583">==</span><span style="color: #E1E4E8"> curr_pred) </span><span style="color: #F97583">/</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">len</span><span style="color: #E1E4E8">(curr_true)))</span></span>
<span class="line"></span>
<span class="line"><span style="color: #E1E4E8">t </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> Task(</span><span style="color: #FFAB70">name</span><span style="color: #F97583">=</span><span style="color: #9ECBFF">"high_tip_prediction"</span><span style="color: #E1E4E8">, </span><span style="color: #FFAB70">description</span><span style="color: #F97583">=</span><span style="color: #9ECBFF">"Predicting high tip for a taxi driver"</span><span style="color: #E1E4E8">)</span></span>
<span class="line"><span style="color: #E1E4E8">t.registerMetric(</span><span style="color: #FFAB70">name</span><span style="color: #F97583">=</span><span style="color: #9ECBFF">"accuracy"</span><span style="color: #E1E4E8">, </span><span style="color: #FFAB70">window</span><span style="color: #F97583">=</span><span style="color: #E1E4E8">timedelta(</span><span style="color: #FFAB70">hours</span><span style="color: #F97583">=</span><span style="color: #79B8FF">2</span><span style="color: #E1E4E8">), </span><span style="color: #FFAB70">fn</span><span style="color: #F97583">=</span><span style="color: #E1E4E8">compute_accuracy)</span></span>
<span class="line"></span>
<span class="line"><span style="color: #79B8FF">...</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A737D"># Under the hood, we automatically compute metrics based on</span></span>
<span class="line"><span style="color: #6A737D"># params defined above. User calls the following:</span></span>
<span class="line"><span style="color: #E1E4E8">t.logOutputs(</span><span style="color: #79B8FF">...</span><span style="color: #E1E4E8">)</span></span>
<span class="line"><span style="color: #E1E4E8">t.logFeedback(</span><span style="color: #79B8FF">...</span><span style="color: #E1E4E8">)</span></span></code></pre>
<p>In the workflow above, users define their own metric functions and instrument their code with logging functions. We would need to join outputs and feedbacks – incrementally, to save time – and compute metrics over arbitrary window sizes. A preliminary prototype<sup><a href="#user-content-fn-4" id="user-content-fnref-4" data-footnote-ref="" aria-describedby="footnote-label">4</a></sup> to compute streaming ML SLIs, defined as Python UDFs, across different components, shows promising metric computation time and minimal logging overhead:</p>
<p><img src="/blogimages/monitoring4querylatencyall.png" alt="Query Latency">
<img src="/blogimages/monitoring4loggingtimeall.png" alt="Logging Latency">
<em>Figure 1: ML query and logging latency.</em></p>
<p><strong>Querying.</strong> Supporting fast <em>and</em> flexible queries is of utmost importance. Precomputing and storing summaries – including joins and metric values – before users query yields the lowest latency queries; however, users may want to vary window sizes and other parameters at query time. What is the best tradeoff between precomputing before query time and computing everything on the fly? Furthermore, as users add new UDFs and new subgroups arise over time, how do we efficiently backfill metric values for all windows since deployment?</p>
<h5 id="estimating-real-time-slis-with-label-lag">Estimating Real-Time SLIs with Label Lag</h5>
<p>Not only do we need to consider monitoring infrastructure, but we also need to be able to compute SLIs <em>correctly</em>. Lag introduces interesting algorithmic challenges to computing SLIs. If users don’t receive labels (feedback) for all predictions in a timely manner, how do we estimate real-time SLIs as correctly as possible?</p>
<h6 id="full-feedback">Full-Feedback</h6>
<p>To compute an SLI over a window in this case, we simply need to perform a streaming join. Challenges occur at scale, or when our window size is too large to fit predictions and feedback in-memory. One natural solution might be to perform approximate streaming joins, but it is well-known that uniformly subsampling streams before a join can yield quadratically fewer tuples in the result <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.101.9077&#x26;rep=rep1&#x26;type=pdf">(Chaudhuri et al.)</a>. Existing approximate query processing (AQP) techniques for streaming joins trade off accuracy between the <em>number of tuples</em> or the <em>representativeness</em> of the resulting join. In our case, we care about the latter because we want to minimize the error of our SLI approximation (i.e. approximated accuracy should be close to exact accuracy). So we might not want to leverage state-of-the-art universe sampling techniques <a href="https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.1060.3316&#x26;rep=rep1&#x26;type=pdf">(Kandula et al.)</a> that retain large numbers of join result tuples because they don’t necessarily provide <em>accurate</em> estimates <a href="http://www.vldb.org/pvldb/vol13/p547-huang.pdf">(Huang et al.)</a>.</p>
<p>To prioritize representativeness in our joined sample, we can draw inspiration from stratified sampling techniques in progressive approximate joins <a href="https://openproceedings.org/2008/conf/edbt/TokBL08.pdf">(Tok et al.)</a>. Intuitively, to minimize the error of our SLI approximation, we should construct strata, or subgroups, that share similar prediction errors (i.e. losses deemed by the ML model objective). Unfortunately, in our high-data setting, we can’t compute errors for each prediction (because we can’t join each prediction on its corresponding label)! Maybe we can identify “exemplars” (i.e. “important” data points) in high-level feature groupings and join exemplars on group labels. For example, in our high tip prediction problem, we can group our predictions and labels by neighborhood (e.g. FiDi, Tribeca, Midtown), pick exemplars in these groups, aggregate predictions and labels for these exemplars, and join them to compute metrics. Research challenges lie in devising efficient, high-accuracy methods – possibly a hybrid of ML and data processing techniques – to compute groups and exemplars.<sup><a href="#user-content-fn-5" id="user-content-fnref-5" data-footnote-ref="" aria-describedby="footnote-label">5</a></sup></p>
<h6 id="no-feedback">No-Feedback</h6>
<p>This scenario typically occurs immediately after deployment. In our NYC taxicab example, suppose we have two sources of raw data: taxi sensor telemetry data (e.g. mileage, location) and meter data (e.g. payment information). The meter data might come in batch at a later date, motivating us to find alternative ways to estimate real-time performance without labels.</p>
<p>One idea is to use importance weighting (IW) techniques <a href="https://www.jmlr.org/papers/volume8/sugiyama07a/sugiyama07a.pdf">(Sugiyama et al.)</a>. At a high level, we could identify subgroups based on input features, figure out the training SLI (e.g. accuracy) for each subgroup, and weight these accuracies based on the number of points in each subgroup in the live (post-deployment, unlabeled) data. In our example, basic subgroup definitions could be neighborhoods – for each neighborhood in NYC, we’d find the training accuracy and weight it by the fraction of live points in that corresponding neighborhood to get its “estimated” accuracy. Then, we’d aggregate each neighborhood’s estimates to get an overall estimated accuracy. For a more sophisticated (and higher-confidence) approach, we could construct different subgroupings and average the resulting SLI estimates. Again, research challenges lie in identifying these subgroups, and of course – assessing how well such methods work.</p>
<p>We could either identify subgroups in the training set or in the live stream. The cheapest option is to compute subgroups based on training data points, as this can be done once. However, with this “static subgroup” option, real-time SLI estimates become less accurate as subgroup representation changes over time. Thus, we want to compute <em>adaptive</em> subgroupings in the live data. We could leverage streaming clustering algorithms that are explicitly robust to changing data distributions <a href="https://arxiv.org/pdf/2007.10781.pdf">(Zubaroğlu et al.)</a>; however, this is extra costly in our case because we would repeatedly need to reassign training dataset points to clusters any time new live data comes in. Additionally, clusters might have few or no corresponding data points in the training set, preventing us from estimating the SLI. Thus, we need to research <strong>methods that efficiently identify subgroups in high-dimensional, changing data streams with a reference dataset in mind</strong> (i.e. training set).</p>
<h6 id="partial-feedback">Partial Feedback</h6>
<p>This scenario is the most common amongst ML pipelines I’ve seen “in the wild.” Often, live data is only labeled on a schedule, and more often than not, some upstream data collection issues influence feedback coming in (e.g. there’s a cell tower outage in a region of Tribeca, causing payment meter data to arrive later than expected). Assuming <strong>the distribution of label lag is unknown and nonstationary</strong> (i.e. it may not be feasible to train a separate model to predict which predictions won’t have feedback), how do we estimate real-time SLIs in this case?</p>
<p>At a first glance, maybe we can simply aggregate the full-feedback and no-feedback estimates, weighted by the count of data points in each subgroup. But the reality is that label lag is rarely uniformly distributed across buckets, and identifying groups of data points that have similar feedback lag times is critical to producing accurate estimates of real-time SLIs<sup><a href="#user-content-fn-6" id="user-content-fnref-6" data-footnote-ref="" aria-describedby="footnote-label">6</a></sup>. We could leverage the streaming clustering algorithms as described in the no-feedback section, but such clusters may not be interpretable, or simply described with only a few clauses in the predicate <a href="https://dl.acm.org/doi/abs/10.1145/3375627.3375843">(Saisubramanian et al.)</a>. For debugging purposes, we also care about how these clusters of “laggy” data points change over time, or <em>anomalies</em> in lag.</p>
<p>Maybe we can draw inspiration from streaming pattern mining algorithms such as frequent itemsets <a href="http://infolab.stanford.edu/~ullman/mmds/ch6.pdf">(Rajaraman and Ullman et al.)</a>. However, such algorithms look through groups of features in windows of data points with labels that don’t change, while the data points we want to apply the frequent itemsets algorithm to – the ones that don’t have feedback (i.e. the “laggy” points) – might get feedback after we compute the frequent itemsets. Consequently, <strong>how do we extend streaming frequent itemset algorithms to efficiently recompute itemsets after removing data points?</strong> We can build on work in incremental maintenance of frequent itemsets <a href="https://www.semanticscholar.org/paper/Incremental-Maintenance-of-Frequent-Itemsets-in-Tobji-Yaghlane/9a942975aa086b53c7db6d4616163efbfba6319a">(Tobji et al.)</a>.</p>
<h4 id="fine-grained-monitoring-diagnosing-ml-performance-issues">Fine-grained Monitoring: <em>Diagnosing</em> ML Performance Issues</h4>
<p>When SLIs are low, the highest priority is to get them back up as soon as possible. The “fine-grained” monitoring category deals with “root cause analysis” for underperforming pipelines – whether models should be retrained or if engineering problems in the pipeline are root causes of failure. Furthermore, if models should be retrained (e.g. there is “drift” or “shift”), how should we change the training set to increase performance?</p>
<h5 id="detecting-data-quality-issues">Detecting Data Quality Issues</h5>
<p>Research in data management for ML observability has made strides in automatically identifying engineering issues in data pipelines (<a href="https://www.vldb.org/pvldb/vol11/p1781-schelter.pdf">Schelter et al.</a>, <a href="https://mlsys.org/Conferences/2019/doc/2019/167.pdf">Breck et al.</a>). Techniques such as schema validation, detecting outliers within batches, and constraints on statistics (e.g. expected mean, completeness, and ranges) of features can flag unexpected data quality issues such as broken sensors and incomplete upstream data ingestion. Declaring bounds or expectations might be feasible with a handful of features and high familiarity with the problem domain, but can this scale to high-dimensional settings – for example, when data scientists are throwing 2000 or more features at an xgboost model? Furthermore, <strong>drawing the line between “engineering issue” and “drift” is hard</strong>, especially if we want to automate detecting issues. Tools like TFX <a href="https://research.google/pubs/pub46484/">(Modi et al.)</a> allow users to monitor distance metrics of interest like KL divergence and the Kolmogorov-Smirnov test statistic, but these fail in cases where visually-inspected L<sub>1</sub> distance is low – which can happen at the scale of thousands of data points <a href="https://mlsys.org/Conferences/2019/doc/2019/167.pdf">(Breck et al.)</a>. Strategies to mitigate this problem assume having the number of data points that a FAANG company might be working with (hundreds of millions, if not billions). If outside a FAANG company, what techniques can we use to bridge the gap between empirical drift <em>d(p̂, q̂)</em> and theoretical drift <em>d(p, q)</em> where <em>p</em> and <em>q</em> are two different distributions?</p>
<h5 id="towards-retraining-models">Towards Retraining Models</h5>
<p>A massive problem in both research and practitioner communities is that <strong>“distribution shift” is a poorly defined and overloaded phrase</strong>, causing confusion across the board. When people say “distribution shift,” they refer to a phenomenon where one dataset comes from a different distribution than another dataset. “Distribution shift” could cause an ML performance degradation – for example, models trained on one taxi company provider’s data might perform poorly on data taken from another taxi company provider. This overloaded phrase encompasses different types of shift; for example:</p>
<ul>
<li><strong>Concept shift:</strong> a change in the relationship between input features and target outputs (i.e. labels). An example of this is end-of-year Wall Street bonuses causing riders to tip more for a week.</li>
<li><strong>Covariate shift:</strong> a change in the distribution of input variables in the training data, not the target output distribution. An example of this is receiving more taxi rides in Midtown (Times Square for the ball drop) on New Year’s Eve.</li>
<li><strong>Age shift:</strong> an expected increase or decrease in the distribution for an input variable over time. An example of this is a taxicab’s total mileage, which can only increase over time.</li>
</ul>
<p>A lot of research and existing methods in “distribution shift” focus on comparing two finite sets of data. As I’ve mentioned earlier in this series, in practice, we care about deploying models over infinite streams of data, or data for the foreseeable future. Are we supposed to arbitrarily cut production data into two fixed-size datasets to wonder if there is a “distribution shift?” This doesn’t seem right. In the streaming ML setting, the question we really care about is: at what point does my model not work as expected for my current data (i.e. <strong>when do I need to retrain my model?</strong>).</p>
<p>In reality, decreases in SLIs result from combinations of different types of shift, especially in highly nonstationary environments. Thinking from a product perspective, how actionable is telling a user that “78% comes from concept shift and 22% from covariate shift,” even if we could precisely determine this breakdown? <strong>We want to tell users when and how to retrain models post-deployment</strong>, given the “abnormalities” occurring in the current window of data. Suppose we have labels or feedback <em>Y</em> and input data or features <em>X</em>, where <em>X<sub>i</sub></em> represents data for the _i_th feature across all data points. In order of increasing granularity, types of abnormalities could include:</p>
<ul>
<li>Shift in <em>P(Y | X)</em> but no shift in <em>P(X)</em></li>
<li>No shift in <em>P(Y | X)</em> but shift in <em>P(X)</em></li>
<li>Shift in <em>P(X<sub>i</sub>)</em></li>
<li>Shift in <em>P(X<sub>i</sub> | X<sub>j</sub>)</em> where <em>i</em> ≠ <em>j</em></li>
<li>Shift in <em>P(X<sub>i</sub> | X<sub>j</sub> , X<sub>k</sub> , …)</em> where <em>i</em> ≠ <em>j</em> ≠ <em>k</em></li>
</ul>
<p><strong>Tracking many distance metrics at scale.</strong> As mentioned earlier, to approximate the abnormalities described above, existing works propose tracking metrics like KL divergence and the Kolmogorov-Smirnov tests over both consecutive sliding windows and train sets (i.e. for train-serve skew as described in <a href="https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/aad9f93b86b7addfea4c419b9100c6cdd26cacea.pdf">Breck et al.</a>). Keeping many windows of live data and the train set in-memory might not be feasible, so we could leverage AQP techniques to compute distance metrics with reasonable errors. For example, metric computation functions could run on histograms of features instead of full data streams; however, histogram bins need to change in the streaming setting as data evolves over time. Research challenges lie in combining ideas from incrementally-maintained approximate histograms (<a href="http://theory.stanford.edu/~matias/papers/vldb97_tods.pdf">Gibbons et al.</a>) with ideas from adaptive histograms (<a href="https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.4.2075&#x26;rep=rep1&#x26;type=pdf">Leow et al.</a>) to produce evolving summaries of windows of data.</p>
<p><strong>Identifying stationarity in distance metrics.</strong> Oftentimes, models underperform on weekends, outside of working hours, or on holidays. One interesting idea is to train a model to identify whether there are seasonal patterns in distances between observed <em>P(Y | X)</em> and <em>P(X)</em> in sliding windows. Tracking all combinations of features is impractical <a href="http://www.vldb.org/pvldb/vol7/p301-heise.pdf">(Heise et al.)</a>, so is it possible to leverage predicate-finding algorithms (e.g., <a href="http://sirrice.github.io/files/papers/scorpion-vldb13.pdf">Wu et al.</a>) to simplify the space of distance metrics to track?</p>
<p><strong>Self-tuning training sets.</strong> Finally, based on the types of abnormalities detected, we can suggest ways to augment or change the training set. For example, in the case where <em>P(X)</em> changes but <em>P(Y | X)</em> is the same, we can suggest an upsample of underrepresented subpopulations. In the case where <em>P(Y | X)</em> changes but <em>P(X)</em> remains the same, maybe users can retrain their model on a recent window of data. Research challenges lie in specific, useful hints to construct new training datasets to avoid low performance pitfalls.</p>
<h3 id="visualizations">Visualizations</h3>
<p><strong>Current ML monitoring dashboards are <a href="https://www.google.com/search?q=data+drift+dashboard&#x26;sxsrf=APq-WBvY6B9IVmkta48sYCYRqfW8IwXINw:1643594450380&#x26;source=lnms&#x26;tbm=isch&#x26;sa=X&#x26;ved=2ahUKEwjIifq68tr1AhX4JEQIHQp-BdwQ_AUoAXoECAEQAw">overloaded with information</a>.</strong><sup><a href="#user-content-fn-7" id="user-content-fnref-7" data-footnote-ref="" aria-describedby="footnote-label">7</a></sup> Users see hundreds, or even thousands, of bar charts and graphs trying to visualize “distribution shift.” <strong>These charts are not actionable, especially when people can use the same group of charts to tell two conflicting stories.</strong> For instance, a user could argue that a model needs to be retrained because a feature’s mean value has plummeted in the last few days. On the other hand, a user could argue that this feature isn’t one of the three most important features, so retraining the model wouldn’t have a large impact. Thus, from an interface perspective, drawing the line on when to retrain a model given hundreds of graphs is an arbitrary process. How do we come up with better visualization tools?</p>
<p><strong>Dashboard goals.</strong> The purpose of monitoring visualizations is to help users be in sync with their data and models. To this end, good monitoring dashboard should unambiguously answer specific questions, such as:</p>
<ul>
<li>What is the real-time ML performance?</li>
<li>Is this performance higher or lower than expected? Than required (i.e. meeting SLOs)?</li>
<li>Is the reason for lower performance a data quality issue?</li>
<li>Should the model be retrained?</li>
</ul>
<p>Dashboards should contain only a handful of plots describing the “single metric to rule them all” (i.e. SLIs) so users aren’t overwhelmed.</p>
<p><strong>Dashboard challenges.</strong> Visualizing metrics across more than two dimensions is very hard. Unfortunately, we have at least the following dimensions when it comes to ML metrics:</p>
<ul>
<li>Metric value</li>
<li>Components (i.e. joins across components in pipelines, see the single-component vs cross-component discussion in the second essay in this series)</li>
<li>State (i.e. historical values of inputs and outputs)</li>
<li>Subpopulation (including groups of features)</li>
<li>Time (in the generic sense, e.g. plotting the rolling mean of 100-day windows across the last 6 months)</li>
</ul>
<p>How do we develop visualizations that unambiguously communicate information across all these dimensions without too much cognitive overhead?</p>
<p><strong>Towards insightful visualizations.</strong> Coupled with fine-grained monitoring information as described in the earlier section, a good dashboard will have insightful visualizations to give users intuition for how distributions are changing. Existing “state-of-the-art” visualizations that ML engineers use (determined via word-of-mouth, so take with a grain of salt<sup><a href="#user-content-fn-8" id="user-content-fnref-8" data-footnote-ref="" aria-describedby="footnote-label">8</a></sup>) include static bar chart histograms comparing two datasets. This is hard to reason about in a streaming ML setting. What new types of visualizations can explain changes in fine-grained metrics? Here’s an example of a “dynamic” violin plot of high tip predictions that shows how the distribution of outputs changes over time:</p>
<p><img src="/blogimages/monitoring4output_violin.gif" alt="Output distribution">
<em>Figure 2: Output distribution over time.</em></p>
<p>In the example above, there is a confirmed decrease in the SLI (accuracy), as we have full feedback (i.e. all predictions have labels). In cases where we need to approximate the SLI and hypothetically reason about fine-grained metrics, maybe users could intuitively see seasonality in such a visualization. This is definitely not the end-all-be-all solution, but going back to the main point: <strong>research challenges lie in principled ways to come up with better visualizations for understanding data drift and automatically presenting these to users based on the data and ML tasks they work with.</strong></p>
<h3 id="datasets--benchmarks">Datasets &#x26; Benchmarks</h3>
<p>Many researchers and developers work mainly with toy data or synthetic distribution shifts due to lack of access to “real-world” streaming ML tasks. To this end, a few problems revolve around datasets and benchmarks to accelerate progress in ML monitoring:</p>
<ol>
<li><strong>A repository of real-time streams of data that correspond to tractable ML tasks.</strong> Properties of a good data stream include: it’s infinite, representative of a real-world phenomenon, and has an ML task that’s easier to solve than predicting the weather or stock prices. A particularly high-impact problem might be Ethereum gas price prediction. Specifically, can a model output the minimum gas price necessary for a transaction to go through in the next hour with 95% confidence? Another option is to convert existing benchmarks to a streaming format (e.g. samples point <em>x<sub>t</sub></em> from train and test distributions (<em>D</em> and <em>D’</em>) from WILDS with a function where <em>x<sub>t</sub> ∈ D</em> with high probability when timestamp <em>t</em> is small and <em>x<sub>t</sub> ∈ D’</em> with high probability when <em>t</em> is large). Ideally, we collect more <a href="https://twitter.com/TweetAtAKK/status/1486026387525804034?s=20">“temporally evolving tabular data streams,”</a> as this type of data is massively underrepresented in research communities.</li>
<li><strong>Interfaces for querying data from the repository in an intuitive way.</strong> Most data scientists don’t work with streaming systems, so how do we allow them to perform range queries and receive Pandas or PyTorch datasets? How do we safeguard users against label leakage or accidentally peeking into the future when they experiment with new ideas?</li>
<li><strong>Interfaces</strong> (dare I say, a <a href="https://en.wikipedia.org/wiki/Domain-specific_language">DSL</a>? <strong>for creating and evaluating <em>policies</em> for training models, not single model binaries</strong> (i.e. as a Kaggle competition would). <a href="https://github.com/loglabs/mltrace">mltrace’s</a> vision is to be a React-like library where users define components of pipelines with triggers that run before and after every component is run. In these triggers, users can decide to retrain models based on their own criteria – such as data drift metrics or scheduled updates.</li>
</ol>
<h2 id="conclusion">Conclusion</h2>
<p>With enough context about an ML task, it’s probably possible to solve the data management problems specific to that task. But in building a general-purpose monitoring tool, there are several other challenges that stem from increased ML pipeline and system complexity, including:</p>
<ul>
<li><strong>Growing data science teams and tool stacks.</strong> Software engineering has shown that fragmentation in teams and tool stacks makes it hard to keep up system sustainability. This will hold for ML, especially when the number of possible ML data management tools largely increases every year. Debugging a model that someone else trained is a pain.</li>
<li><strong>Model stacking.</strong> Many organizations chain models together to produce final predictions. Drift detection is hard enough for one model. Tracing faulty predictions back to the specific model(s) that need to be debugged seems extra challenging.</li>
<li><strong>Uninterpretable features.</strong> Many organizations use ML to produce embeddings that are fed as features to downstream ML tasks.<sup><a href="#user-content-fn-9" id="user-content-fnref-9" data-footnote-ref="" aria-describedby="footnote-label">9</a></sup> Data quality alerts, such as user-defined constraints on feature columns, then cannot be constructed.</li>
<li><strong>Deploying components as containerized applications.</strong> It is hard to do ML in Kubernetes clusters. Containerized infrastructure works well primarily for stateless applications, and unfortunately, online and continual learning is stateful (i.e. model weights are updated and need to be shared across prediction serving pods).</li>
<li><strong>Multimodal data.</strong> Many of the solution ideas I outlined in this piece are specific to tabular data. What techniques can we use in image, audio, and video cases? Dare I say, <a href="https://aws.amazon.com/big-data/datalakes-and-analytics/what-is-a-data-lake/">“data lakes”</a> of information?</li>
</ul>
<p>I haven’t thought too deeply about these ad-hoc challenges, but I suspect that a good ML monitoring tool will be aware of them at least. Finally, I want to end this series on a personal note.<sup><a href="#user-content-fn-10" id="user-content-fnref-10" data-footnote-ref="" aria-describedby="footnote-label">10</a></sup> I am grateful to have the time to critically think about ML monitoring and the support of both industry professionals and academic collaborators. I am lucky to be in a PhD, and I’m excited for the papers I will be able to write!</p>
<p><em>Thanks to <a href="https://twitter.com/divyahansg">Divyahans Gupta</a> and my advisor <a href="https://twitter.com/adityagp">Aditya Parameswaran</a> for brainstorming help and feedback on many drafts.</em></p>
<!-- Footnotes themselves at the bottom. -->
<h2 id="notes">Notes</h2>
<section data-footnotes="" class="footnotes"><h2 class="sr-only" id="footnote-label">Footnotes</h2>
<ol>
<li id="user-content-fn-1">
<p>Usually, I talk about observability. Monitoring is a subproblem within observability, with the most interesting research questions (in my opinion). <a href="#user-content-fnref-1" data-footnote-backref="" class="data-footnote-backref" aria-label="Back to content">↩</a></p>
</li>
<li id="user-content-fn-2">
<p>New challenges arise with model <em>stacking</em>, or chaining models together to create final predictions. <a href="#user-content-fnref-2" data-footnote-backref="" class="data-footnote-backref" aria-label="Back to content">↩</a></p>
</li>
<li id="user-content-fn-3">
<p>Unclear if “coarse-grained” and “fine-grained” are the best terms here. DG suggests “external” vs “internal” metrics. Please let me know if you have any thoughts on this! <a href="#user-content-fnref-3" data-footnote-backref="" class="data-footnote-backref" aria-label="Back to content">↩</a></p>
</li>
<li id="user-content-fn-4">
<p>Based on <a href="https://github.com/timelydataflow/differential-dataflow">timely-dataflow</a> (Rust-based differential dataflow implementation). Shoutout to <a href="https://twitter.com/pschafhalter">Peter Schafhalter</a> for the quick work on this. <a href="#user-content-fnref-4" data-footnote-backref="" class="data-footnote-backref" aria-label="Back to content">↩</a></p>
</li>
<li id="user-content-fn-5">
<p>I should elaborate on these methods further. <a href="#user-content-fnref-5" data-footnote-backref="" class="data-footnote-backref" aria-label="Back to content">↩</a></p>
</li>
<li id="user-content-fn-6">
<p>Not to mention, determining which subgroups have higher lag times can be helpful for debugging purposes. <a href="#user-content-fnref-6" data-footnote-backref="" class="data-footnote-backref" aria-label="Back to content">↩</a></p>
</li>
<li id="user-content-fn-7">
<p>Not naming any names here, but please check out demos from ML monitoring companies if you are interested. <a href="#user-content-fnref-7" data-footnote-backref="" class="data-footnote-backref" aria-label="Back to content">↩</a></p>
</li>
<li id="user-content-fn-8">
<p>A few of us in RISELab are working on an interview study to formally write about “best practices” for post-deployment ML maintenance. <a href="#user-content-fnref-8" data-footnote-backref="" class="data-footnote-backref" aria-label="Back to content">↩</a></p>
</li>
<li id="user-content-fn-9">
<p>The perils of deep learning fall into this category. <a href="#user-content-fnref-9" data-footnote-backref="" class="data-footnote-backref" aria-label="Back to content">↩</a></p>
</li>
<li id="user-content-fn-10">
<p>Kudos to anyone who has made it through all 4 posts in this series. Seriously. I’m pretty sure I haven’t read all the words in here. <a href="#user-content-fnref-10" data-footnote-backref="" class="data-footnote-backref" aria-label="Back to content">↩</a></p>
</li>
</ol>
</section>

        </div>
      </article>
    </main>
    <footer class="astro-SZ7XMLTE">
  &copy; 2023 Shreya Shankar. All rights reserved. Website
  modified from <a href="https://github.com/withastro/astro/tree/main/examples/blog" target="_blank" class="astro-SZ7XMLTE">Astro</a>.
  <div class="social-links astro-SZ7XMLTE">
    <a href="https://twitter.com/sh_reya" target="_blank" class="astro-SZ7XMLTE">
      <span class="sr-only astro-SZ7XMLTE">Follow Shreya on Twitter</span>
      <svg viewBox="0 0 16 16" aria-hidden="true" width="32" height="32" astro-icon="social/twitter" class="astro-SZ7XMLTE"><path fill="currentColor" d="M5.026 15c6.038 0 9.341-5.003 9.341-9.334 0-.14 0-.282-.006-.422A6.685 6.685 0 0 0 16 3.542a6.658 6.658 0 0 1-1.889.518 3.301 3.301 0 0 0 1.447-1.817 6.533 6.533 0 0 1-2.087.793A3.286 3.286 0 0 0 7.875 6.03a9.325 9.325 0 0 1-6.767-3.429 3.289 3.289 0 0 0 1.018 4.382A3.323 3.323 0 0 1 .64 6.575v.045a3.288 3.288 0 0 0 2.632 3.218 3.203 3.203 0 0 1-.865.115 3.23 3.23 0 0 1-.614-.057 3.283 3.283 0 0 0 3.067 2.277A6.588 6.588 0 0 1 .78 13.58a6.32 6.32 0 0 1-.78-.045A9.344 9.344 0 0 0 5.026 15z" class="astro-SZ7XMLTE"></path></svg>
    </a>
    <a href="https://github.com/shreyashankar" target="_blank" class="astro-SZ7XMLTE">
      <span class="sr-only astro-SZ7XMLTE">Shreya's GitHub</span>
      <svg viewBox="0 0 16 16" aria-hidden="true" width="32" height="32" astro-icon="social/github" class="astro-SZ7XMLTE"><path fill="currentColor" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.012 8.012 0 0 0 16 8c0-4.42-3.58-8-8-8z" class="astro-SZ7XMLTE"></path></svg>
    </a>
  </div>
</footer>
  </body></html>